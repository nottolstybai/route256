// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package loms_old

//go:generate minimock -i route256.ozon.ru/project/loms/internal/service.OrderRepository -o order_repository_mock_test.go -n OrderRepositoryMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/loms/internal/entity"
)

// OrderRepositoryMock implements OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, userID int64, items []entity.Item) (o1 entity.OrderID, err error)
	inspectFuncCreate   func(ctx context.Context, userID int64, items []entity.Item)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderRepositoryMockCreate

	funcGetByOrderID          func(ctx context.Context, orderID entity.OrderID) (op1 *entity.OrderInfo, err error)
	inspectFuncGetByOrderID   func(ctx context.Context, orderID entity.OrderID)
	afterGetByOrderIDCounter  uint64
	beforeGetByOrderIDCounter uint64
	GetByOrderIDMock          mOrderRepositoryMockGetByOrderID

	funcSetStatus          func(ctx context.Context, orderID entity.OrderID, status entity.Status) (err error)
	inspectFuncSetStatus   func(ctx context.Context, orderID entity.OrderID, status entity.Status)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderRepositoryMockSetStatus
}

// NewOrderRepositoryMock returns a mock for OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrderRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderRepositoryMockCreateParams{}

	m.GetByOrderIDMock = mOrderRepositoryMockGetByOrderID{mock: m}
	m.GetByOrderIDMock.callArgs = []*OrderRepositoryMockGetByOrderIDParams{}

	m.SetStatusMock = mOrderRepositoryMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderRepositoryMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockCreate struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockCreateExpectation
	expectations       []*OrderRepositoryMockCreateExpectation

	callArgs []*OrderRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockCreateExpectation specifies expectation struct of the OrderRepository.Create
type OrderRepositoryMockCreateExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockCreateParams
	results *OrderRepositoryMockCreateResults
	Counter uint64
}

// OrderRepositoryMockCreateParams contains parameters of the OrderRepository.Create
type OrderRepositoryMockCreateParams struct {
	ctx    context.Context
	userID int64
	items  []entity.Item
}

// OrderRepositoryMockCreateResults contains results of the OrderRepository.Create
type OrderRepositoryMockCreateResults struct {
	o1  entity.OrderID
	err error
}

// Expect sets up expected params for OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Expect(ctx context.Context, userID int64, items []entity.Item) *mOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &OrderRepositoryMockCreateParams{ctx, userID, items}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Inspect(f func(ctx context.Context, userID int64, items []entity.Item)) *mOrderRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrderRepository.Create
func (mmCreate *mOrderRepositoryMockCreate) Return(o1 entity.OrderID, err error) *OrderRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderRepositoryMockCreateResults{o1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the OrderRepository.Create method
func (mmCreate *mOrderRepositoryMockCreate) Set(f func(ctx context.Context, userID int64, items []entity.Item) (o1 entity.OrderID, err error)) *OrderRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrderRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrderRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the OrderRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderRepositoryMockCreate) When(ctx context.Context, userID int64, items []entity.Item) *OrderRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderRepositoryMock.Create mock is already set by Set")
	}

	expectation := &OrderRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &OrderRepositoryMockCreateParams{ctx, userID, items},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.Create return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockCreateExpectation) Then(o1 entity.OrderID, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockCreateResults{o1, err}
	return e.mock
}

// Create implements OrderRepository
func (mmCreate *OrderRepositoryMock) Create(ctx context.Context, userID int64, items []entity.Item) (o1 entity.OrderID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, userID, items)
	}

	mm_params := OrderRepositoryMockCreateParams{ctx, userID, items}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := OrderRepositoryMockCreateParams{ctx, userID, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderRepositoryMock.Create")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, userID, items)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderRepositoryMock.Create. %v %v %v", ctx, userID, items)
	return
}

// CreateAfterCounter returns a count of finished OrderRepositoryMock.Create invocations
func (mmCreate *OrderRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderRepositoryMock.Create invocations
func (mmCreate *OrderRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderRepositoryMockCreate) Calls() []*OrderRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.Create")
	}
}

type mOrderRepositoryMockGetByOrderID struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByOrderIDExpectation
	expectations       []*OrderRepositoryMockGetByOrderIDExpectation

	callArgs []*OrderRepositoryMockGetByOrderIDParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockGetByOrderIDExpectation specifies expectation struct of the OrderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockGetByOrderIDParams
	results *OrderRepositoryMockGetByOrderIDResults
	Counter uint64
}

// OrderRepositoryMockGetByOrderIDParams contains parameters of the OrderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDParams struct {
	ctx     context.Context
	orderID entity.OrderID
}

// OrderRepositoryMockGetByOrderIDResults contains results of the OrderRepository.GetByOrderID
type OrderRepositoryMockGetByOrderIDResults struct {
	op1 *entity.OrderInfo
	err error
}

// Expect sets up expected params for OrderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Expect(ctx context.Context, orderID entity.OrderID) *mOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderRepositoryMockGetByOrderIDExpectation{}
	}

	mmGetByOrderID.defaultExpectation.params = &OrderRepositoryMockGetByOrderIDParams{ctx, orderID}
	for _, e := range mmGetByOrderID.expectations {
		if minimock.Equal(e.params, mmGetByOrderID.defaultExpectation.params) {
			mmGetByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByOrderID.defaultExpectation.params)
		}
	}

	return mmGetByOrderID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Inspect(f func(ctx context.Context, orderID entity.OrderID)) *mOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByOrderID")
	}

	mmGetByOrderID.mock.inspectFuncGetByOrderID = f

	return mmGetByOrderID
}

// Return sets up results that will be returned by OrderRepository.GetByOrderID
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Return(op1 *entity.OrderInfo, err error) *OrderRepositoryMock {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderRepositoryMockGetByOrderIDExpectation{mock: mmGetByOrderID.mock}
	}
	mmGetByOrderID.defaultExpectation.results = &OrderRepositoryMockGetByOrderIDResults{op1, err}
	return mmGetByOrderID.mock
}

// Set uses given function f to mock the OrderRepository.GetByOrderID method
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Set(f func(ctx context.Context, orderID entity.OrderID) (op1 *entity.OrderInfo, err error)) *OrderRepositoryMock {
	if mmGetByOrderID.defaultExpectation != nil {
		mmGetByOrderID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetByOrderID method")
	}

	if len(mmGetByOrderID.expectations) > 0 {
		mmGetByOrderID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetByOrderID method")
	}

	mmGetByOrderID.mock.funcGetByOrderID = f
	return mmGetByOrderID.mock
}

// When sets expectation for the OrderRepository.GetByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) When(ctx context.Context, orderID entity.OrderID) *OrderRepositoryMockGetByOrderIDExpectation {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByOrderIDExpectation{
		mock:   mmGetByOrderID.mock,
		params: &OrderRepositoryMockGetByOrderIDParams{ctx, orderID},
	}
	mmGetByOrderID.expectations = append(mmGetByOrderID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetByOrderID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByOrderIDExpectation) Then(op1 *entity.OrderInfo, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByOrderIDResults{op1, err}
	return e.mock
}

// GetByOrderID implements OrderRepository
func (mmGetByOrderID *OrderRepositoryMock) GetByOrderID(ctx context.Context, orderID entity.OrderID) (op1 *entity.OrderInfo, err error) {
	mm_atomic.AddUint64(&mmGetByOrderID.beforeGetByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByOrderID.afterGetByOrderIDCounter, 1)

	if mmGetByOrderID.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.inspectFuncGetByOrderID(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetByOrderIDParams{ctx, orderID}

	// Record call args
	mmGetByOrderID.GetByOrderIDMock.mutex.Lock()
	mmGetByOrderID.GetByOrderIDMock.callArgs = append(mmGetByOrderID.GetByOrderIDMock.callArgs, &mm_params)
	mmGetByOrderID.GetByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetByOrderID.GetByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetByOrderID.GetByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByOrderID.GetByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.params
		mm_got := OrderRepositoryMockGetByOrderIDParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByOrderID.t.Errorf("OrderRepositoryMock.GetByOrderID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByOrderID.t.Fatal("No results are set for the OrderRepositoryMock.GetByOrderID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetByOrderID.funcGetByOrderID != nil {
		return mmGetByOrderID.funcGetByOrderID(ctx, orderID)
	}
	mmGetByOrderID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByOrderID. %v %v", ctx, orderID)
	return
}

// GetByOrderIDAfterCounter returns a count of finished OrderRepositoryMock.GetByOrderID invocations
func (mmGetByOrderID *OrderRepositoryMock) GetByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.afterGetByOrderIDCounter)
}

// GetByOrderIDBeforeCounter returns a count of OrderRepositoryMock.GetByOrderID invocations
func (mmGetByOrderID *OrderRepositoryMock) GetByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.beforeGetByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByOrderID *mOrderRepositoryMockGetByOrderID) Calls() []*OrderRepositoryMockGetByOrderIDParams {
	mmGetByOrderID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByOrderIDParams, len(mmGetByOrderID.callArgs))
	copy(argCopy, mmGetByOrderID.callArgs)

	mmGetByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByOrderIDDone returns true if the count of the GetByOrderID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByOrderIDDone() bool {
	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOrderIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOrderID != nil && mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByOrderIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByOrderIDInspect() {
	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOrderIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter) < 1 {
		if m.GetByOrderIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.GetByOrderID")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByOrderID with params: %#v", *m.GetByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOrderID != nil && mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.GetByOrderID")
	}
}

type mOrderRepositoryMockSetStatus struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSetStatusExpectation
	expectations       []*OrderRepositoryMockSetStatusExpectation

	callArgs []*OrderRepositoryMockSetStatusParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockSetStatusExpectation specifies expectation struct of the OrderRepository.SetStatus
type OrderRepositoryMockSetStatusExpectation struct {
	mock    *OrderRepositoryMock
	params  *OrderRepositoryMockSetStatusParams
	results *OrderRepositoryMockSetStatusResults
	Counter uint64
}

// OrderRepositoryMockSetStatusParams contains parameters of the OrderRepository.SetStatus
type OrderRepositoryMockSetStatusParams struct {
	ctx     context.Context
	orderID entity.OrderID
	status  entity.Status
}

// OrderRepositoryMockSetStatusResults contains results of the OrderRepository.SetStatus
type OrderRepositoryMockSetStatusResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Expect(ctx context.Context, orderID entity.OrderID, status entity.Status) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{}
	}

	mmSetStatus.defaultExpectation.params = &OrderRepositoryMockSetStatusParams{ctx, orderID, status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Inspect(f func(ctx context.Context, orderID entity.OrderID, status entity.Status)) *mOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OrderRepository.SetStatus
func (mmSetStatus *mOrderRepositoryMockSetStatus) Return(err error) *OrderRepositoryMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepositoryMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderRepositoryMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the OrderRepository.SetStatus method
func (mmSetStatus *mOrderRepositoryMockSetStatus) Set(f func(ctx context.Context, orderID entity.OrderID, status entity.Status) (err error)) *OrderRepositoryMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OrderRepository.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OrderRepository.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the OrderRepository.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderRepositoryMockSetStatus) When(ctx context.Context, orderID entity.OrderID, status entity.Status) *OrderRepositoryMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepositoryMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderRepositoryMockSetStatusParams{ctx, orderID, status},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSetStatusExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSetStatusResults{err}
	return e.mock
}

// SetStatus implements OrderRepository
func (mmSetStatus *OrderRepositoryMock) SetStatus(ctx context.Context, orderID entity.OrderID, status entity.Status) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := OrderRepositoryMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_got := OrderRepositoryMockSetStatusParams{ctx, orderID, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderRepositoryMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderRepositoryMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderRepositoryMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrderRepositoryMock.SetStatus invocations
func (mmSetStatus *OrderRepositoryMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderRepositoryMock.SetStatus invocations
func (mmSetStatus *OrderRepositoryMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderRepositoryMockSetStatus) Calls() []*OrderRepositoryMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSetStatusDone() bool {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.SetStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByOrderIDInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByOrderIDDone() &&
		m.MinimockSetStatusDone()
}
