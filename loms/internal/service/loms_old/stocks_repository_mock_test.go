// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package loms_old

//go:generate minimock -i route256.ozon.ru/project/loms/internal/service.StocksRepository -o stocks_repository_mock_test.go -n StocksRepositoryMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"route256.ozon.ru/project/loms/internal/entity"
)

// StocksRepositoryMock implements StocksRepository
type StocksRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelReservation          func(ctx context.Context, items []entity.Item) (err error)
	inspectFuncCancelReservation   func(ctx context.Context, items []entity.Item)
	afterCancelReservationCounter  uint64
	beforeCancelReservationCounter uint64
	CancelReservationMock          mStocksRepositoryMockCancelReservation

	funcGetBySku          func(ctx context.Context, sku uint32) (c2 entity.Count, err error)
	inspectFuncGetBySku   func(ctx context.Context, sku uint32)
	afterGetBySkuCounter  uint64
	beforeGetBySkuCounter uint64
	GetBySkuMock          mStocksRepositoryMockGetBySku

	funcRemoveReservation          func(ctx context.Context, items []entity.Item) (err error)
	inspectFuncRemoveReservation   func(ctx context.Context, items []entity.Item)
	afterRemoveReservationCounter  uint64
	beforeRemoveReservationCounter uint64
	RemoveReservationMock          mStocksRepositoryMockRemoveReservation

	funcReserve          func(ctx context.Context, items []entity.Item) (err error)
	inspectFuncReserve   func(ctx context.Context, items []entity.Item)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStocksRepositoryMockReserve
}

// NewStocksRepositoryMock returns a mock for StocksRepository
func NewStocksRepositoryMock(t minimock.Tester) *StocksRepositoryMock {
	m := &StocksRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelReservationMock = mStocksRepositoryMockCancelReservation{mock: m}
	m.CancelReservationMock.callArgs = []*StocksRepositoryMockCancelReservationParams{}

	m.GetBySkuMock = mStocksRepositoryMockGetBySku{mock: m}
	m.GetBySkuMock.callArgs = []*StocksRepositoryMockGetBySkuParams{}

	m.RemoveReservationMock = mStocksRepositoryMockRemoveReservation{mock: m}
	m.RemoveReservationMock.callArgs = []*StocksRepositoryMockRemoveReservationParams{}

	m.ReserveMock = mStocksRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StocksRepositoryMockReserveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStocksRepositoryMockCancelReservation struct {
	mock               *StocksRepositoryMock
	defaultExpectation *StocksRepositoryMockCancelReservationExpectation
	expectations       []*StocksRepositoryMockCancelReservationExpectation

	callArgs []*StocksRepositoryMockCancelReservationParams
	mutex    sync.RWMutex
}

// StocksRepositoryMockCancelReservationExpectation specifies expectation struct of the StocksRepository.CancelReservation
type StocksRepositoryMockCancelReservationExpectation struct {
	mock    *StocksRepositoryMock
	params  *StocksRepositoryMockCancelReservationParams
	results *StocksRepositoryMockCancelReservationResults
	Counter uint64
}

// StocksRepositoryMockCancelReservationParams contains parameters of the StocksRepository.CancelReservation
type StocksRepositoryMockCancelReservationParams struct {
	ctx   context.Context
	items []entity.Item
}

// StocksRepositoryMockCancelReservationResults contains results of the StocksRepository.CancelReservation
type StocksRepositoryMockCancelReservationResults struct {
	err error
}

// Expect sets up expected params for StocksRepository.CancelReservation
func (mmCancelReservation *mStocksRepositoryMockCancelReservation) Expect(ctx context.Context, items []entity.Item) *mStocksRepositoryMockCancelReservation {
	if mmCancelReservation.mock.funcCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("StocksRepositoryMock.CancelReservation mock is already set by Set")
	}

	if mmCancelReservation.defaultExpectation == nil {
		mmCancelReservation.defaultExpectation = &StocksRepositoryMockCancelReservationExpectation{}
	}

	mmCancelReservation.defaultExpectation.params = &StocksRepositoryMockCancelReservationParams{ctx, items}
	for _, e := range mmCancelReservation.expectations {
		if minimock.Equal(e.params, mmCancelReservation.defaultExpectation.params) {
			mmCancelReservation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelReservation.defaultExpectation.params)
		}
	}

	return mmCancelReservation
}

// Inspect accepts an inspector function that has same arguments as the StocksRepository.CancelReservation
func (mmCancelReservation *mStocksRepositoryMockCancelReservation) Inspect(f func(ctx context.Context, items []entity.Item)) *mStocksRepositoryMockCancelReservation {
	if mmCancelReservation.mock.inspectFuncCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("Inspect function is already set for StocksRepositoryMock.CancelReservation")
	}

	mmCancelReservation.mock.inspectFuncCancelReservation = f

	return mmCancelReservation
}

// Return sets up results that will be returned by StocksRepository.CancelReservation
func (mmCancelReservation *mStocksRepositoryMockCancelReservation) Return(err error) *StocksRepositoryMock {
	if mmCancelReservation.mock.funcCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("StocksRepositoryMock.CancelReservation mock is already set by Set")
	}

	if mmCancelReservation.defaultExpectation == nil {
		mmCancelReservation.defaultExpectation = &StocksRepositoryMockCancelReservationExpectation{mock: mmCancelReservation.mock}
	}
	mmCancelReservation.defaultExpectation.results = &StocksRepositoryMockCancelReservationResults{err}
	return mmCancelReservation.mock
}

// Set uses given function f to mock the StocksRepository.CancelReservation method
func (mmCancelReservation *mStocksRepositoryMockCancelReservation) Set(f func(ctx context.Context, items []entity.Item) (err error)) *StocksRepositoryMock {
	if mmCancelReservation.defaultExpectation != nil {
		mmCancelReservation.mock.t.Fatalf("Default expectation is already set for the StocksRepository.CancelReservation method")
	}

	if len(mmCancelReservation.expectations) > 0 {
		mmCancelReservation.mock.t.Fatalf("Some expectations are already set for the StocksRepository.CancelReservation method")
	}

	mmCancelReservation.mock.funcCancelReservation = f
	return mmCancelReservation.mock
}

// When sets expectation for the StocksRepository.CancelReservation which will trigger the result defined by the following
// Then helper
func (mmCancelReservation *mStocksRepositoryMockCancelReservation) When(ctx context.Context, items []entity.Item) *StocksRepositoryMockCancelReservationExpectation {
	if mmCancelReservation.mock.funcCancelReservation != nil {
		mmCancelReservation.mock.t.Fatalf("StocksRepositoryMock.CancelReservation mock is already set by Set")
	}

	expectation := &StocksRepositoryMockCancelReservationExpectation{
		mock:   mmCancelReservation.mock,
		params: &StocksRepositoryMockCancelReservationParams{ctx, items},
	}
	mmCancelReservation.expectations = append(mmCancelReservation.expectations, expectation)
	return expectation
}

// Then sets up StocksRepository.CancelReservation return parameters for the expectation previously defined by the When method
func (e *StocksRepositoryMockCancelReservationExpectation) Then(err error) *StocksRepositoryMock {
	e.results = &StocksRepositoryMockCancelReservationResults{err}
	return e.mock
}

// CancelReservation implements StocksRepository
func (mmCancelReservation *StocksRepositoryMock) CancelReservation(ctx context.Context, items []entity.Item) (err error) {
	mm_atomic.AddUint64(&mmCancelReservation.beforeCancelReservationCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelReservation.afterCancelReservationCounter, 1)

	if mmCancelReservation.inspectFuncCancelReservation != nil {
		mmCancelReservation.inspectFuncCancelReservation(ctx, items)
	}

	mm_params := StocksRepositoryMockCancelReservationParams{ctx, items}

	// Record call args
	mmCancelReservation.CancelReservationMock.mutex.Lock()
	mmCancelReservation.CancelReservationMock.callArgs = append(mmCancelReservation.CancelReservationMock.callArgs, &mm_params)
	mmCancelReservation.CancelReservationMock.mutex.Unlock()

	for _, e := range mmCancelReservation.CancelReservationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelReservation.CancelReservationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelReservation.CancelReservationMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelReservation.CancelReservationMock.defaultExpectation.params
		mm_got := StocksRepositoryMockCancelReservationParams{ctx, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelReservation.t.Errorf("StocksRepositoryMock.CancelReservation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelReservation.CancelReservationMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelReservation.t.Fatal("No results are set for the StocksRepositoryMock.CancelReservation")
		}
		return (*mm_results).err
	}
	if mmCancelReservation.funcCancelReservation != nil {
		return mmCancelReservation.funcCancelReservation(ctx, items)
	}
	mmCancelReservation.t.Fatalf("Unexpected call to StocksRepositoryMock.CancelReservation. %v %v", ctx, items)
	return
}

// CancelReservationAfterCounter returns a count of finished StocksRepositoryMock.CancelReservation invocations
func (mmCancelReservation *StocksRepositoryMock) CancelReservationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReservation.afterCancelReservationCounter)
}

// CancelReservationBeforeCounter returns a count of StocksRepositoryMock.CancelReservation invocations
func (mmCancelReservation *StocksRepositoryMock) CancelReservationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReservation.beforeCancelReservationCounter)
}

// Calls returns a list of arguments used in each call to StocksRepositoryMock.CancelReservation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelReservation *mStocksRepositoryMockCancelReservation) Calls() []*StocksRepositoryMockCancelReservationParams {
	mmCancelReservation.mutex.RLock()

	argCopy := make([]*StocksRepositoryMockCancelReservationParams, len(mmCancelReservation.callArgs))
	copy(argCopy, mmCancelReservation.callArgs)

	mmCancelReservation.mutex.RUnlock()

	return argCopy
}

// MinimockCancelReservationDone returns true if the count of the CancelReservation invocations corresponds
// the number of defined expectations
func (m *StocksRepositoryMock) MinimockCancelReservationDone() bool {
	for _, e := range m.CancelReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReservationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelReservationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReservation != nil && mm_atomic.LoadUint64(&m.afterCancelReservationCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelReservationInspect logs each unmet expectation
func (m *StocksRepositoryMock) MinimockCancelReservationInspect() {
	for _, e := range m.CancelReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksRepositoryMock.CancelReservation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReservationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelReservationCounter) < 1 {
		if m.CancelReservationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksRepositoryMock.CancelReservation")
		} else {
			m.t.Errorf("Expected call to StocksRepositoryMock.CancelReservation with params: %#v", *m.CancelReservationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReservation != nil && mm_atomic.LoadUint64(&m.afterCancelReservationCounter) < 1 {
		m.t.Error("Expected call to StocksRepositoryMock.CancelReservation")
	}
}

type mStocksRepositoryMockGetBySku struct {
	mock               *StocksRepositoryMock
	defaultExpectation *StocksRepositoryMockGetBySkuExpectation
	expectations       []*StocksRepositoryMockGetBySkuExpectation

	callArgs []*StocksRepositoryMockGetBySkuParams
	mutex    sync.RWMutex
}

// StocksRepositoryMockGetBySkuExpectation specifies expectation struct of the StocksRepository.GetBySku
type StocksRepositoryMockGetBySkuExpectation struct {
	mock    *StocksRepositoryMock
	params  *StocksRepositoryMockGetBySkuParams
	results *StocksRepositoryMockGetBySkuResults
	Counter uint64
}

// StocksRepositoryMockGetBySkuParams contains parameters of the StocksRepository.GetBySku
type StocksRepositoryMockGetBySkuParams struct {
	ctx context.Context
	sku uint32
}

// StocksRepositoryMockGetBySkuResults contains results of the StocksRepository.GetBySku
type StocksRepositoryMockGetBySkuResults struct {
	c2  entity.Count
	err error
}

// Expect sets up expected params for StocksRepository.GetBySku
func (mmGetBySku *mStocksRepositoryMockGetBySku) Expect(ctx context.Context, sku uint32) *mStocksRepositoryMockGetBySku {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StocksRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StocksRepositoryMockGetBySkuExpectation{}
	}

	mmGetBySku.defaultExpectation.params = &StocksRepositoryMockGetBySkuParams{ctx, sku}
	for _, e := range mmGetBySku.expectations {
		if minimock.Equal(e.params, mmGetBySku.defaultExpectation.params) {
			mmGetBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySku.defaultExpectation.params)
		}
	}

	return mmGetBySku
}

// Inspect accepts an inspector function that has same arguments as the StocksRepository.GetBySku
func (mmGetBySku *mStocksRepositoryMockGetBySku) Inspect(f func(ctx context.Context, sku uint32)) *mStocksRepositoryMockGetBySku {
	if mmGetBySku.mock.inspectFuncGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("Inspect function is already set for StocksRepositoryMock.GetBySku")
	}

	mmGetBySku.mock.inspectFuncGetBySku = f

	return mmGetBySku
}

// Return sets up results that will be returned by StocksRepository.GetBySku
func (mmGetBySku *mStocksRepositoryMockGetBySku) Return(c2 entity.Count, err error) *StocksRepositoryMock {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StocksRepositoryMock.GetBySku mock is already set by Set")
	}

	if mmGetBySku.defaultExpectation == nil {
		mmGetBySku.defaultExpectation = &StocksRepositoryMockGetBySkuExpectation{mock: mmGetBySku.mock}
	}
	mmGetBySku.defaultExpectation.results = &StocksRepositoryMockGetBySkuResults{c2, err}
	return mmGetBySku.mock
}

// Set uses given function f to mock the StocksRepository.GetBySku method
func (mmGetBySku *mStocksRepositoryMockGetBySku) Set(f func(ctx context.Context, sku uint32) (c2 entity.Count, err error)) *StocksRepositoryMock {
	if mmGetBySku.defaultExpectation != nil {
		mmGetBySku.mock.t.Fatalf("Default expectation is already set for the StocksRepository.GetBySku method")
	}

	if len(mmGetBySku.expectations) > 0 {
		mmGetBySku.mock.t.Fatalf("Some expectations are already set for the StocksRepository.GetBySku method")
	}

	mmGetBySku.mock.funcGetBySku = f
	return mmGetBySku.mock
}

// When sets expectation for the StocksRepository.GetBySku which will trigger the result defined by the following
// Then helper
func (mmGetBySku *mStocksRepositoryMockGetBySku) When(ctx context.Context, sku uint32) *StocksRepositoryMockGetBySkuExpectation {
	if mmGetBySku.mock.funcGetBySku != nil {
		mmGetBySku.mock.t.Fatalf("StocksRepositoryMock.GetBySku mock is already set by Set")
	}

	expectation := &StocksRepositoryMockGetBySkuExpectation{
		mock:   mmGetBySku.mock,
		params: &StocksRepositoryMockGetBySkuParams{ctx, sku},
	}
	mmGetBySku.expectations = append(mmGetBySku.expectations, expectation)
	return expectation
}

// Then sets up StocksRepository.GetBySku return parameters for the expectation previously defined by the When method
func (e *StocksRepositoryMockGetBySkuExpectation) Then(c2 entity.Count, err error) *StocksRepositoryMock {
	e.results = &StocksRepositoryMockGetBySkuResults{c2, err}
	return e.mock
}

// GetBySku implements StocksRepository
func (mmGetBySku *StocksRepositoryMock) GetBySku(ctx context.Context, sku uint32) (c2 entity.Count, err error) {
	mm_atomic.AddUint64(&mmGetBySku.beforeGetBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySku.afterGetBySkuCounter, 1)

	if mmGetBySku.inspectFuncGetBySku != nil {
		mmGetBySku.inspectFuncGetBySku(ctx, sku)
	}

	mm_params := StocksRepositoryMockGetBySkuParams{ctx, sku}

	// Record call args
	mmGetBySku.GetBySkuMock.mutex.Lock()
	mmGetBySku.GetBySkuMock.callArgs = append(mmGetBySku.GetBySkuMock.callArgs, &mm_params)
	mmGetBySku.GetBySkuMock.mutex.Unlock()

	for _, e := range mmGetBySku.GetBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetBySku.GetBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySku.GetBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySku.GetBySkuMock.defaultExpectation.params
		mm_got := StocksRepositoryMockGetBySkuParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySku.t.Errorf("StocksRepositoryMock.GetBySku got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySku.GetBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySku.t.Fatal("No results are set for the StocksRepositoryMock.GetBySku")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetBySku.funcGetBySku != nil {
		return mmGetBySku.funcGetBySku(ctx, sku)
	}
	mmGetBySku.t.Fatalf("Unexpected call to StocksRepositoryMock.GetBySku. %v %v", ctx, sku)
	return
}

// GetBySkuAfterCounter returns a count of finished StocksRepositoryMock.GetBySku invocations
func (mmGetBySku *StocksRepositoryMock) GetBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySku.afterGetBySkuCounter)
}

// GetBySkuBeforeCounter returns a count of StocksRepositoryMock.GetBySku invocations
func (mmGetBySku *StocksRepositoryMock) GetBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySku.beforeGetBySkuCounter)
}

// Calls returns a list of arguments used in each call to StocksRepositoryMock.GetBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySku *mStocksRepositoryMockGetBySku) Calls() []*StocksRepositoryMockGetBySkuParams {
	mmGetBySku.mutex.RLock()

	argCopy := make([]*StocksRepositoryMockGetBySkuParams, len(mmGetBySku.callArgs))
	copy(argCopy, mmGetBySku.callArgs)

	mmGetBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySkuDone returns true if the count of the GetBySku invocations corresponds
// the number of defined expectations
func (m *StocksRepositoryMock) MinimockGetBySkuDone() bool {
	for _, e := range m.GetBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySku != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetBySkuInspect logs each unmet expectation
func (m *StocksRepositoryMock) MinimockGetBySkuInspect() {
	for _, e := range m.GetBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksRepositoryMock.GetBySku with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySkuMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		if m.GetBySkuMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksRepositoryMock.GetBySku")
		} else {
			m.t.Errorf("Expected call to StocksRepositoryMock.GetBySku with params: %#v", *m.GetBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySku != nil && mm_atomic.LoadUint64(&m.afterGetBySkuCounter) < 1 {
		m.t.Error("Expected call to StocksRepositoryMock.GetBySku")
	}
}

type mStocksRepositoryMockRemoveReservation struct {
	mock               *StocksRepositoryMock
	defaultExpectation *StocksRepositoryMockRemoveReservationExpectation
	expectations       []*StocksRepositoryMockRemoveReservationExpectation

	callArgs []*StocksRepositoryMockRemoveReservationParams
	mutex    sync.RWMutex
}

// StocksRepositoryMockRemoveReservationExpectation specifies expectation struct of the StocksRepository.RemoveReservation
type StocksRepositoryMockRemoveReservationExpectation struct {
	mock    *StocksRepositoryMock
	params  *StocksRepositoryMockRemoveReservationParams
	results *StocksRepositoryMockRemoveReservationResults
	Counter uint64
}

// StocksRepositoryMockRemoveReservationParams contains parameters of the StocksRepository.RemoveReservation
type StocksRepositoryMockRemoveReservationParams struct {
	ctx   context.Context
	items []entity.Item
}

// StocksRepositoryMockRemoveReservationResults contains results of the StocksRepository.RemoveReservation
type StocksRepositoryMockRemoveReservationResults struct {
	err error
}

// Expect sets up expected params for StocksRepository.RemoveReservation
func (mmRemoveReservation *mStocksRepositoryMockRemoveReservation) Expect(ctx context.Context, items []entity.Item) *mStocksRepositoryMockRemoveReservation {
	if mmRemoveReservation.mock.funcRemoveReservation != nil {
		mmRemoveReservation.mock.t.Fatalf("StocksRepositoryMock.RemoveReservation mock is already set by Set")
	}

	if mmRemoveReservation.defaultExpectation == nil {
		mmRemoveReservation.defaultExpectation = &StocksRepositoryMockRemoveReservationExpectation{}
	}

	mmRemoveReservation.defaultExpectation.params = &StocksRepositoryMockRemoveReservationParams{ctx, items}
	for _, e := range mmRemoveReservation.expectations {
		if minimock.Equal(e.params, mmRemoveReservation.defaultExpectation.params) {
			mmRemoveReservation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveReservation.defaultExpectation.params)
		}
	}

	return mmRemoveReservation
}

// Inspect accepts an inspector function that has same arguments as the StocksRepository.RemoveReservation
func (mmRemoveReservation *mStocksRepositoryMockRemoveReservation) Inspect(f func(ctx context.Context, items []entity.Item)) *mStocksRepositoryMockRemoveReservation {
	if mmRemoveReservation.mock.inspectFuncRemoveReservation != nil {
		mmRemoveReservation.mock.t.Fatalf("Inspect function is already set for StocksRepositoryMock.RemoveReservation")
	}

	mmRemoveReservation.mock.inspectFuncRemoveReservation = f

	return mmRemoveReservation
}

// Return sets up results that will be returned by StocksRepository.RemoveReservation
func (mmRemoveReservation *mStocksRepositoryMockRemoveReservation) Return(err error) *StocksRepositoryMock {
	if mmRemoveReservation.mock.funcRemoveReservation != nil {
		mmRemoveReservation.mock.t.Fatalf("StocksRepositoryMock.RemoveReservation mock is already set by Set")
	}

	if mmRemoveReservation.defaultExpectation == nil {
		mmRemoveReservation.defaultExpectation = &StocksRepositoryMockRemoveReservationExpectation{mock: mmRemoveReservation.mock}
	}
	mmRemoveReservation.defaultExpectation.results = &StocksRepositoryMockRemoveReservationResults{err}
	return mmRemoveReservation.mock
}

// Set uses given function f to mock the StocksRepository.RemoveReservation method
func (mmRemoveReservation *mStocksRepositoryMockRemoveReservation) Set(f func(ctx context.Context, items []entity.Item) (err error)) *StocksRepositoryMock {
	if mmRemoveReservation.defaultExpectation != nil {
		mmRemoveReservation.mock.t.Fatalf("Default expectation is already set for the StocksRepository.RemoveReservation method")
	}

	if len(mmRemoveReservation.expectations) > 0 {
		mmRemoveReservation.mock.t.Fatalf("Some expectations are already set for the StocksRepository.RemoveReservation method")
	}

	mmRemoveReservation.mock.funcRemoveReservation = f
	return mmRemoveReservation.mock
}

// When sets expectation for the StocksRepository.RemoveReservation which will trigger the result defined by the following
// Then helper
func (mmRemoveReservation *mStocksRepositoryMockRemoveReservation) When(ctx context.Context, items []entity.Item) *StocksRepositoryMockRemoveReservationExpectation {
	if mmRemoveReservation.mock.funcRemoveReservation != nil {
		mmRemoveReservation.mock.t.Fatalf("StocksRepositoryMock.RemoveReservation mock is already set by Set")
	}

	expectation := &StocksRepositoryMockRemoveReservationExpectation{
		mock:   mmRemoveReservation.mock,
		params: &StocksRepositoryMockRemoveReservationParams{ctx, items},
	}
	mmRemoveReservation.expectations = append(mmRemoveReservation.expectations, expectation)
	return expectation
}

// Then sets up StocksRepository.RemoveReservation return parameters for the expectation previously defined by the When method
func (e *StocksRepositoryMockRemoveReservationExpectation) Then(err error) *StocksRepositoryMock {
	e.results = &StocksRepositoryMockRemoveReservationResults{err}
	return e.mock
}

// RemoveReservation implements StocksRepository
func (mmRemoveReservation *StocksRepositoryMock) RemoveReservation(ctx context.Context, items []entity.Item) (err error) {
	mm_atomic.AddUint64(&mmRemoveReservation.beforeRemoveReservationCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveReservation.afterRemoveReservationCounter, 1)

	if mmRemoveReservation.inspectFuncRemoveReservation != nil {
		mmRemoveReservation.inspectFuncRemoveReservation(ctx, items)
	}

	mm_params := StocksRepositoryMockRemoveReservationParams{ctx, items}

	// Record call args
	mmRemoveReservation.RemoveReservationMock.mutex.Lock()
	mmRemoveReservation.RemoveReservationMock.callArgs = append(mmRemoveReservation.RemoveReservationMock.callArgs, &mm_params)
	mmRemoveReservation.RemoveReservationMock.mutex.Unlock()

	for _, e := range mmRemoveReservation.RemoveReservationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveReservation.RemoveReservationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveReservation.RemoveReservationMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveReservation.RemoveReservationMock.defaultExpectation.params
		mm_got := StocksRepositoryMockRemoveReservationParams{ctx, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveReservation.t.Errorf("StocksRepositoryMock.RemoveReservation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveReservation.RemoveReservationMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveReservation.t.Fatal("No results are set for the StocksRepositoryMock.RemoveReservation")
		}
		return (*mm_results).err
	}
	if mmRemoveReservation.funcRemoveReservation != nil {
		return mmRemoveReservation.funcRemoveReservation(ctx, items)
	}
	mmRemoveReservation.t.Fatalf("Unexpected call to StocksRepositoryMock.RemoveReservation. %v %v", ctx, items)
	return
}

// RemoveReservationAfterCounter returns a count of finished StocksRepositoryMock.RemoveReservation invocations
func (mmRemoveReservation *StocksRepositoryMock) RemoveReservationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveReservation.afterRemoveReservationCounter)
}

// RemoveReservationBeforeCounter returns a count of StocksRepositoryMock.RemoveReservation invocations
func (mmRemoveReservation *StocksRepositoryMock) RemoveReservationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveReservation.beforeRemoveReservationCounter)
}

// Calls returns a list of arguments used in each call to StocksRepositoryMock.RemoveReservation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveReservation *mStocksRepositoryMockRemoveReservation) Calls() []*StocksRepositoryMockRemoveReservationParams {
	mmRemoveReservation.mutex.RLock()

	argCopy := make([]*StocksRepositoryMockRemoveReservationParams, len(mmRemoveReservation.callArgs))
	copy(argCopy, mmRemoveReservation.callArgs)

	mmRemoveReservation.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveReservationDone returns true if the count of the RemoveReservation invocations corresponds
// the number of defined expectations
func (m *StocksRepositoryMock) MinimockRemoveReservationDone() bool {
	for _, e := range m.RemoveReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveReservationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveReservationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveReservation != nil && mm_atomic.LoadUint64(&m.afterRemoveReservationCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveReservationInspect logs each unmet expectation
func (m *StocksRepositoryMock) MinimockRemoveReservationInspect() {
	for _, e := range m.RemoveReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksRepositoryMock.RemoveReservation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveReservationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveReservationCounter) < 1 {
		if m.RemoveReservationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksRepositoryMock.RemoveReservation")
		} else {
			m.t.Errorf("Expected call to StocksRepositoryMock.RemoveReservation with params: %#v", *m.RemoveReservationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveReservation != nil && mm_atomic.LoadUint64(&m.afterRemoveReservationCounter) < 1 {
		m.t.Error("Expected call to StocksRepositoryMock.RemoveReservation")
	}
}

type mStocksRepositoryMockReserve struct {
	mock               *StocksRepositoryMock
	defaultExpectation *StocksRepositoryMockReserveExpectation
	expectations       []*StocksRepositoryMockReserveExpectation

	callArgs []*StocksRepositoryMockReserveParams
	mutex    sync.RWMutex
}

// StocksRepositoryMockReserveExpectation specifies expectation struct of the StocksRepository.Reserve
type StocksRepositoryMockReserveExpectation struct {
	mock    *StocksRepositoryMock
	params  *StocksRepositoryMockReserveParams
	results *StocksRepositoryMockReserveResults
	Counter uint64
}

// StocksRepositoryMockReserveParams contains parameters of the StocksRepository.Reserve
type StocksRepositoryMockReserveParams struct {
	ctx   context.Context
	items []entity.Item
}

// StocksRepositoryMockReserveResults contains results of the StocksRepository.Reserve
type StocksRepositoryMockReserveResults struct {
	err error
}

// Expect sets up expected params for StocksRepository.Reserve
func (mmReserve *mStocksRepositoryMockReserve) Expect(ctx context.Context, items []entity.Item) *mStocksRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksRepositoryMockReserveExpectation{}
	}

	mmReserve.defaultExpectation.params = &StocksRepositoryMockReserveParams{ctx, items}
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the StocksRepository.Reserve
func (mmReserve *mStocksRepositoryMockReserve) Inspect(f func(ctx context.Context, items []entity.Item)) *mStocksRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StocksRepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by StocksRepository.Reserve
func (mmReserve *mStocksRepositoryMockReserve) Return(err error) *StocksRepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksRepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StocksRepositoryMockReserveResults{err}
	return mmReserve.mock
}

// Set uses given function f to mock the StocksRepository.Reserve method
func (mmReserve *mStocksRepositoryMockReserve) Set(f func(ctx context.Context, items []entity.Item) (err error)) *StocksRepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the StocksRepository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the StocksRepository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	return mmReserve.mock
}

// When sets expectation for the StocksRepository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStocksRepositoryMockReserve) When(ctx context.Context, items []entity.Item) *StocksRepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksRepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &StocksRepositoryMockReserveExpectation{
		mock:   mmReserve.mock,
		params: &StocksRepositoryMockReserveParams{ctx, items},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up StocksRepository.Reserve return parameters for the expectation previously defined by the When method
func (e *StocksRepositoryMockReserveExpectation) Then(err error) *StocksRepositoryMock {
	e.results = &StocksRepositoryMockReserveResults{err}
	return e.mock
}

// Reserve implements StocksRepository
func (mmReserve *StocksRepositoryMock) Reserve(ctx context.Context, items []entity.Item) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, items)
	}

	mm_params := StocksRepositoryMockReserveParams{ctx, items}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_got := StocksRepositoryMockReserveParams{ctx, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StocksRepositoryMock.Reserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StocksRepositoryMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, items)
	}
	mmReserve.t.Fatalf("Unexpected call to StocksRepositoryMock.Reserve. %v %v", ctx, items)
	return
}

// ReserveAfterCounter returns a count of finished StocksRepositoryMock.Reserve invocations
func (mmReserve *StocksRepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StocksRepositoryMock.Reserve invocations
func (mmReserve *StocksRepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StocksRepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStocksRepositoryMockReserve) Calls() []*StocksRepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StocksRepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StocksRepositoryMock) MinimockReserveDone() bool {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		return false
	}
	return true
}

// MinimockReserveInspect logs each unmet expectation
func (m *StocksRepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksRepositoryMock.Reserve with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksRepositoryMock.Reserve")
		} else {
			m.t.Errorf("Expected call to StocksRepositoryMock.Reserve with params: %#v", *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && mm_atomic.LoadUint64(&m.afterReserveCounter) < 1 {
		m.t.Error("Expected call to StocksRepositoryMock.Reserve")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StocksRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelReservationInspect()

			m.MinimockGetBySkuInspect()

			m.MinimockRemoveReservationInspect()

			m.MinimockReserveInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StocksRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StocksRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelReservationDone() &&
		m.MinimockGetBySkuDone() &&
		m.MinimockRemoveReservationDone() &&
		m.MinimockReserveDone()
}
